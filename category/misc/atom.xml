<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Misc | Icebergist]]></title>
  <link href="http://icebergist.com/category/misc/atom.xml" rel="self"/>
  <link href="http://icebergist.com/"/>
  <updated>2016-10-18T09:15:00+02:00</updated>
  <id>http://icebergist.com/</id>
  <author>
    <name><![CDATA[Orange Iceberg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Backup and Restore a PostgreSQL Database]]></title>
    <link href="http://icebergist.com/posts/backup-and-restore-a-postresql-database/"/>
    <updated>2016-10-18T07:05:38+02:00</updated>
    <id>http://icebergist.com/posts/backup-and-restore-a-postresql-database</id>
    <content type="html"><![CDATA[<p>While working on different projects and in different environments, we often need to export a dump from one database and then import it into another. A while ago <a href="http://http://orangeiceberg.com/about/" title="About Slobodan">Slobodan</a> wrote how to <a href="http://icebergist.com/posts/import-and-export-mysql-dump/" title="Import and Export mySQL dump">export and import a mySQL dump</a>, and here is a guide how do it for PostgreSQL.</p>

<h2>Export a PostgreSQL database dump</h2>

<p>To export PostgreSQL database we will need to use the <a href="https://www.postgresql.org/docs/current/static/backup-dump.html" title="PostgreSQL">pg_dump</a> tool, which will dump all the contents of a selected database into a single file.
We need to run <code>pg_dump</code> in the command line on the computer where the database is stored. So, if the database is stored on a remote server, you will need to SSH to that server in order to run the following command:</p>

<p><code>
pg_dump -U db_user -W -F t db_name &gt; /path/to/your/file/dump_name.tar
</code>
Here we used the following options:</p>

<ul>
<li><code>-U</code> to specify which user will connect to the PostgreSQL database server.</li>
<li><code>-W</code> or <code>--password</code> will force pg_dump to prompt for a password before connecting to the server.</li>
<li><code>-F</code> is used to specify the format of the output file, which can be one of the following:

<ul>
<li><code>p</code> &ndash; plain-text SQL script</li>
<li><code>c</code> &ndash; custom-format archive</li>
<li><code>d</code> &ndash; directory-format archive</li>
<li><code>t</code> &ndash; tar-format archive</li>
</ul>
</li>
</ul>


<p><sup><em>custom</em>, <em>directory</em> and <em>tar</em> formats are suitable for input into pg_restore.</sup></p>

<p>To see a list of all the available options use <code>pg_dump -?</code>.</p>

<p>With given options <code>pg_dump</code> will first prompt for a password for the database user <code>db_user</code> and then connect as that user to the database named <code>db_name</code>. After it successfully connects, <code>&gt;</code> will write the output produced by pg_dump to a file with a given name, in this case <code>dump_name.tar</code>.</p>

<p>File created in the described process contains all the SQL queries that are required in order to replicate your database.</p>

<h2>Import a PostgreSQL database dump</h2>

<p>There are two ways to restore a PostgreSQL database:</p>

<ol>
<li><code>psql</code> for restoring from a plain SQL script file created with <code>pg_dump</code>,</li>
<li><code>pg_restore</code> for restoring from a .tar file, directory, or custom format created with <code>pg_dump</code>.</li>
</ol>


<h3>1. Restore a database with psql</h3>

<p>If your backup is a plain-text file containing SQL script, then you can restore your database by using <a href="https://www.postgresql.org/docs/current/static/app-psql.html">PostgreSQL interactive terminal</a>, and running the following command:</p>

<p><code>
psql -U db_user db_name &lt; dump_name.sql
</code>
where <code>db_user</code> is the database user, <code>db_name</code> is the database name, and <code>dump_name.sql</code> is the name of your backup file.</p>

<h3>2. Restore a database with pg_restore</h3>

<p>If you choose custom, directory, or archive format when creating a backup file, then you will need to use pg_restore in order to restore your database:</p>

<p><code>pg_restore -d db_name /path/to/your/file/dump_name.tar -c -U db_user</code></p>

<p>If you use pg_restore you have various options available, for example:</p>

<ul>
<li><code>-c</code> to drop database objects before recreating them,</li>
<li><code>-C</code> to create a database before restoring into it,</li>
<li><code>-e</code> exit if an error has encountered,</li>
<li><code>-F format</code> to specify the format of the archive.</li>
</ul>


<p>Use <code>pg_restore -?</code> to get the full list of available options.</p>

<p>You can find more info on using mentioned tools by running <code>man pg_dump</code>, <code>man psql</code> and <code>man pg_restore</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Import and export MySQL dump]]></title>
    <link href="http://icebergist.com/posts/import-and-export-mysql-dump/"/>
    <updated>2015-12-02T10:44:23+01:00</updated>
    <id>http://icebergist.com/posts/import-and-export-mysql-dump</id>
    <content type="html"><![CDATA[<p>Another simple task that&rsquo;s often hard for beginners is importing and exporting MySQL dumps. Here is quick rundown on how to do it.</p>

<p>To export data you need to use <code>mysqldump</code>:</p>

<p><code>sh
mysqldump -u db_user -p db_name &gt; dump_name.sql
</code></p>

<p>Options given to <code>mysqldump</code> are:</p>

<ul>
<li><code>-u db_user</code> &ndash; connect as user <code>db_user</code> to database</li>
<li><code>-p</code> &ndash; use password, it will ask you to enter your password</li>
<li><code>db_name</code> is the name of MySQL database you want to dump</li>
<li><code>&gt; dump_name.sql</code> &ndash; by default <code>mysqldump</code> will print out the dump to terminal, but simple output redirect with <code>&gt;</code> will instead write it to given filename, in this case <code>dump_name.sql</code></li>
</ul>


<p>Now that you have <code>dump_name.sql</code> file with all SQL queries needed to replicate your database you can import it using general-purpose <code>mysql</code> client:</p>

<p><code>sh
mysql -u db_user -p db_name &lt; dump_name.sql
</code></p>

<p>User, password, and database name options are the same as for <code>mysqldump</code>. Since <code>mysql</code> reads input from terminal this time we can use <code>&lt;</code> to read input from given file instead.</p>

<p>As always for more information you can consult manual using <code>man mysqldump</code> and <code>man mysql</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create and extract archives using tar and gzip]]></title>
    <link href="http://icebergist.com/posts/create-and-extract-archives-using-tar-and-gzip/"/>
    <updated>2015-11-13T13:28:36+01:00</updated>
    <id>http://icebergist.com/posts/create-and-extract-archives-using-tar-and-gzip</id>
    <content type="html"><![CDATA[<p>One of the simplest tasks is creating and extracting files using <code>tar</code> and <code>gzip</code>. Yet for most new developers this is a daunting task. These days <code>tar</code> is mostly used to simply combine a few files into a single file and then <code>gzip</code> is used to compress that file.</p>

<p>Here is a quick overview how to use <code>tar</code> and <code>gzip</code> to create and compress an archive:</p>

<p>```sh</p>

<h1>archive individual files</h1>

<p>tar -cvzf myarchive.tar.gz /path/to/file1 /path/to/file2</p>

<h1>archive whole directory</h1>

<p>tar -cvzf myarchive.tar.gz /path/to/dir</p>

<h1>archive whole directory but don&rsquo;t store full path</h1>

<p>tar -cvzf myarchive.tar.gz -C /path/to/dir ./
```</p>

<p>Options give to tar are: <code>c</code> to create new archive, <code>v</code> to be verbose, <code>z</code> to compress resulting archive with <code>gzip</code>, and <code>f</code> to write the archive to specified file. After options you can list files and dirs you want to archive.</p>

<p>In all examples we provide a full path to a file or dir we want to archive. In this case <code>tar</code> will store files in the archive using the full path. This means once you extract the files you&rsquo;ll have a complete directory structure from root dir onwards.</p>

<p>The way to avoid this is either to manually <code>cd</code> to dir in which files are stored, or to tell <code>tar</code> using <code>C</code> option to change dir before archiving files.</p>

<p>Finally to extract an archive:</p>

<p><code>sh
tar -xvzf myarchive.tar.gz
</code></p>

<p>The <code>x</code> option tells <code>tar</code> to extract the archive into current directory.</p>

<p>For more information you can consult manual using <code>man tar</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Upgrade Ubuntu 8.04 LTS server]]></title>
    <link href="http://icebergist.com/posts/upgrade-ubuntu-8-dot-04-lts-server/"/>
    <updated>2014-01-06T11:36:43+01:00</updated>
    <id>http://icebergist.com/posts/upgrade-ubuntu-8-dot-04-lts-server</id>
    <content type="html"><![CDATA[<p>Note to self: here is how to upgrade Ubuntu 8.04 LTS (or any other release that is no longer supported) to newer Ubuntu release.</p>

<p>When you are upgrading unsupported release of Ubuntu if you try to do the usual <code>sudo apt-get update</code> it will most likely fail because&hellip; well, it&rsquo;s unsupported. The simple fix for this is to change your <code>/etc/apt/sources.list</code> and replace repository URLs from something like <code>us.archive.ubuntu.com</code> to <code>old-releases.ubuntu.com</code>.</p>

<p>After that you should be able follow normal upgrade procedure (use sudo if you are not root):</p>

<p><code>sh
apt-get update
apt-get install update-manager-core
do-release-upgrade
</code></p>

<p>References:</p>

<ul>
<li><a href="http://rimuhosting.com/knowledgebase/linux/distros/ubuntu" title="Rimuhosting's page on upgrading Ubuntu">Rimuhosting&rsquo;s page on upgrading Ubuntu</a></li>
<li><a href="http://askubuntu.com/questions/91815/how-to-install-software-or-upgrade-from-old-unsupported-release" title="Discussion on upgrading unsupported Ubuntu release">Discussion on upgrading unsupported Ubuntu release</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick VirtualBox/Vagrant setup with Heroku-like box]]></title>
    <link href="http://icebergist.com/posts/quick-virtualboxvagrant-setup-with-heroku-like-box"/>
    <updated>2013-09-16T10:00:00+02:00</updated>
    <id>http://icebergist.com/posts/quick-virtualboxvagrant-setup-with-heroku-like-box</id>
    <content type="html"><![CDATA[<p>Here is a quick way to setup VirtualBox using Vagrant with Heroku-like box on Mac.</p>

<ol>
<li><p>Install VirtualBox from <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank"><a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></a></p></li>
<li><p>Install Vagrant from <a href="http://downloads.vagrantup.com/" target="_blank"><a href="http://downloads.vagrantup.com/">http://downloads.vagrantup.com/</a></a></p></li>
<li><p>Create Vagrantfile for Heroku-like box (based on <a href="https://github.com/ejholmes/vagrant-heroku" target="_blank"><a href="https://github.com/ejholmes/vagrant-heroku">https://github.com/ejholmes/vagrant-heroku</a></a>) that looks something like:</p></li>
</ol>


<p>``` ruby</p>

<pre><code>    Vagrant.configure("2") do |config|        
        config.vm.box = "heroku"
        config.vm.box_url = "https://dl.dropboxusercontent.com/s/rnc0p8zl91borei/heroku.box"
      config.vm.synced_folder ".", "/vagrant", :nfs =&gt; true
        config.vm.network :private_network, ip: "192.168.1.42"  # required for NFS
    end
</code></pre>

<p>```</p>

<p>Beside telling Vagrant to use Heroku-like box from <a href="https://github.com/ejholmes/vagrant-heroku" target="_blank"><a href="https://github.com/ejholmes/vagrant-heroku">https://github.com/ejholmes/vagrant-heroku</a></a> it also sets up shared dir between host and VM machine. It will mount Vagrantfile dir (.) to /vagrant in VM.</p>

<p><code>vagrant up</code> will setup the VM and start it up.</p>

<p>Now you can use <code>vagrant ssh</code> to login to VM.</p>

<p>Vagrant Heroku-like box comes with Postgresql, but if you want you can easily setup sqlite:</p>

<p><code>sh
sudo apt-get install libsqlite3-dev
</code></p>

<p><strong>Bonus tip</strong>: when you are working on multiple projects sometimes you can forget which VMs are running. You can list all running VMs using:</p>

<p><code>sh
VBoxManage list runningvms
</code></p>

<p>Further reading:</p>

<ul>
<li><a href="http://docs.vagrantup.com/v2/" target="_blank">Vagrant docs</a></li>
<li><a href="https://github.com/ejholmes/vagrant-heroku" target="_blank">Vagrant Heroku-like box</a> which can be easily customized.</li>
<li><a href="http://loudcoding.com/posts/how-to-use-vagrant-to-run-celadon-cedar-stack-on-heroku/" target="_blank">Another Vagrant setup tutorial</a></li>
<li><a href="https://www.stackmachine.com/blog/web-development-on-a-vm-is-it-slower" target="_blank">VM speed benchmarks</a> in case you doubt in VM speed.</li>
</ul>

]]></content>
  </entry>
  
</feed>
